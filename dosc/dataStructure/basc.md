## 常见数据结构
### 数据结构目录
   - 数组
   - 链表
   - 散列表
   - 树
        + 二叉树
        + 红黑树
        + B-Tree
        + B+Tree
        + 多路查找树   
   - 图
   - 队列
   - 堆
   - 栈
   

### 常见算法目录
   - 快速排序
   - 冒泡排序
   - 插入排序
   - 递归
   - 冒泡排序
   - 斐波那契算法
   
##### 数据结构入门
###### 1. 时间复杂度 [表示算法的执行时间和数据规模之间的增长关系]
![ 这是一个图片 ](image/TimeComplexity.png)
   - 加法法则
     + 总的时间复杂度为量级最大的那段代码的时间复杂度.
       时间复杂度为O(n)
     + 若有两个不定量级的数据规模,如(m,n). 时间复杂度为O(m+n)
   - 乘法法则
     + 通常用于嵌套循环中,如一个循环中调用了另一个循环函数.
     那么该代码的时间复杂度为O(n²)
     + 若为多个不定量级,则复杂度为O(n*m)等
   - 常见的时间复杂度
     - 多项式量级
       + O(1): 常量阶[代码的执行时间不随着不定量级的增长而增长]
       + O(logn): 对数阶[等比数列]
       + O(n): 线性阶
       + O(nlogn): 线性对数阶[循环内嵌套对数阶]
       + O(n²): 平方阶
       + O(n³): 立方阶
       + O(nk): k次方阶
     - 非多项式量级(随着数据规模越大,执行时间急剧增加)
       + O(2n): 指数阶
       + O(!n): 阶乘阶
      
###### 2. 空间复杂度 [表示存储空间和数据规模之间的增长关系]
   - 常见的空间复杂度
     + O(1): 常量阶
     + O(n): 线性阶[new一个不定量级长度的对象/数组等]
     + O(n²)
     + O(logn)/O(nlogn): 不常用

###### 3. 时间复杂度细化
   - 最好情况时间复杂度
     + 最理想情况下出现的时间复杂度
   - 最坏情况时间复杂度
     + 最坏情况下出现的时间复杂度
   - 平均情况时间复杂度
     + 一般为加权平均值(需要考虑到各种情况,进行运算) 一般为O(n)
   - 均摊时间复杂度
     + 大多数为一种情况,偶然出现第二种情况,那么均摊时间复杂度为情况一
       
##### 数据结构基础篇
###### 1. 数组
   - 概念
     + 数组: 是一种线性表数据结构,用一组连续的内存空间来存储相同类型的数据
     + 线性表: 是数据排成像线一样的结构,每个线性表只有前或后两个方向. 如: 数组,链表,栈,队列都属于线性表
     + 非线性表: 数据间并不是简单的前后关系. 如: 堆,图,树等
   - 数组特点
     + 连续的内存空间和相同类型的数据
        1. 优点: 随机访问
        2. 缺点: 为保证连续性,需要做大量的数据搬移工作
     + 数据根据下标随机访问的实现
        1. 计算机通过该数组的内存地址访问,寻址公式: a[i]_address = base_address + i * data_type_size(表示数组中每个元素的大小,单位字节).
        其实下表最确切的定义是偏移.如果用a标识数组的首地址,a[0]就是偏移为0的位置.a[k]就表示偏移k个type_size的位置,所以用上述公式就可以了.
        但如果下标从1开始,后续i的计算都需要-1. 即: base_address + (k-1) * type_size.
        所以如果从1开始,CPU就多了一次减法指令,这也是下标为0的原因.当然,也可能是历史原因,因为从C语言开始,设计者就用0做数组下标.
        2. 根据数组下标随机访问的时候,时间复杂度为O(1). 而整体查找的时间复杂度,几遍是排好序的数组,用二分查找,时间复杂度也是O(logn).链表的增删改则为O(1)
     + 低效的插入和删除
        1. 数组具有连续性,会导致插入删除这两个操作比较低效. 因为他是把插入位置以后的数据进行移动,所以平均时间复杂度是(1+2+3+...+n)/n = O(n)
        如果数据是有序的,就必须将后续数据进行移动,若是无序的,则可以更换位置,如: 将插入位置的原数据放到数组最后,把新元素放入插入位置.
        2. 删除时除了上述移动后续数据的方法,某些特殊场景下,我们可以先把删除的数据进行标记,等到数组没有更多空间的时候,在触发执行一次真正的删除.这样可以大大减少删除操作导致的数据搬移. 这一点和JVM的标记清除垃圾回收算法的核心思想一样
   - 容器和数组的使用场景
     + ArrayList容器
        1. 讲很多数组操作的细节进行封装,且支持动态扩容.但因为扩容操作设计内存申请和数据搬移,比较耗时,所以如果能事先确定好需要存储的数据大小,最好在创建的时候指定大小
     + 数组
        1. 因为容器不支持基本数据类型,而封装类是有一定性能消耗的,所以如果特别关注性能追求极致,或者需要使用基本数据类型,可以使用数组. 若是数据大小事先已知,并且对数据操作简单,用不到大多数封装方法,也可以直接使用数组
        
###### 2. 链表
   - 概念
     + 是一种线性表数据结构,通过指针将一组零散的内存串联起来使用.我们吧每一个内存块称为链表的结点.
     + 为了将所有的结点串起来,每个链表的结点除了存储数据之外,还需要记录链上的下一个结点的地址所以我们把这个记录下个结点地址的指针叫做后继指针next
   - 链表特点
     + 高效的插入删除
        1. 通过指针随时增加或删除结点,所以时间复杂度为O(1).
     + 低效的查询
        1. 单链表
            + 单链表有两个结点比较特殊,分别是头结点和尾结点.头结点用来记录链表的基地址,通过它可以遍历整条链表.尾结点的指针不指向下一个结点,而是指向一个空地址NULL
            + 遍历时,链表就向一个队伍,队伍中的每个人只知道自己后面的人是谁,所以当我们希望知道排在k位的人是谁时,
            我们就需要从第一个人开始,一个一个往下数,所以链表随机访问的性能没有数组好,需要O(n)的时间复杂度
        2. 循环链表
            + 循环链表和单链表唯一的区别在于尾结点,单链表尾结点指向NULL,而循环链表尾结点指向头结点
            + 优点: 从链尾到链头比较方便,当要处理的数据具有环形结构特点时,就特别适合采用循环链表.如:  <big>[约瑟夫问题-见代码](src/main/java/com/ssq/demo/base/dataStructure/linkedList/JosefCircle.java)</big>
        3. 双向链表
            + 双向链表可支持两个方向,每个节点不止有一个后继指针next指向后面的结点,还有一个前驱指针prev指向前面的结点.
            + 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址.所以如果存储同样多的数据,双向链表比单链表占用更多的空间,但可以支持双向遍历,也增加了链表的灵活性
            + 优点: 从结构来看,双向链表可以支持O(1)时间复杂度的情况下找到前驱结点,所以在某些情况下,双向链表的插入删除等操作都比单链表简单高效.
            + 删除操作解析(两种情况) - 插入同理:
                1. 删除结点中"值等于某个给定值"的结点
                    - 需要从头遍历对照,找到该值进行删除.虽然单纯的删除操作时间复杂度为O(1),但遍历查找的时间是主要的耗时点,为O(n); 所以根据时间复杂度分析中的加法法则,链表操作该删除值的总时间复杂度为O(n).
                2. 删除给定指针指向的结点
                    - 我们已经找到了要删除的结点,但是删除某个结点q需要知道其前驱结点,而单链表并不支持直接获取前驱结点,还是要从头节点开始遍历链表,直到p -> next = q. 说明p是q的前驱结点
                    - 但对于双向链表来说,这种情况就比较有优势了.因为双向链表中的结点已经保存下来了前驱结点的指针,不需要像单链表一样遍历.所以针对第二种情况,双链表的时间复杂度就为O(1)了.
            + 查询优势
                1. 可以记录上次查找的位置p,每次查询时,根绝要查找的值与p的大小关系来决定是向前啊还是向后查找.所以平均只需要查找一半的数据
        4. 双向循环链表
        5. 空间换时间思想
            + 当内存空间充足的时候,如果我们更加追求代码的执行速度,就可以选择空间复杂度相对较高,但时间复杂度很低的算法或者数据结构.相反,如果内存紧缺,就要反而行之.
   - 用途
     + 缓存
        1. 缓存是一种提高数据读取性能的技术,在硬件设计,软件开发中都有着非常广泛的应用,比如常见的CPU缓存,数据库缓存,浏览器缓存等.
        而缓存大小有限,当缓存被占满时,数据的去留则需要缓存淘汰策略来决定.
        常见的有三种:先进先出策略(FIFO),最近最少使用策略(LFU),最少使用策略(LRU)
        2. 缓存实际上利用了空间换时间的设计思想.虽然吧数据加载在内存中耗费空间,但数据查询速度非常快
     + LRU缓存淘汰算法实现思路
        1. 维护一个有序单链表,越靠近链表尾部的结点是越早之前访问的.当有一个新的数据被访问时,我们从链表头开始顺序遍历链表.
        2. 如果此数据之前已经被缓存到链表中了,我们遍历得到这个数据对应的结点,并将其从原来的位置删除,然后在插入到链表的头部.
        3. 如果此数据没有在缓存链表中,可分为两种情况:
            + 如果此时缓存未满,则将此结点直接插入到链表头部
            + 若缓存已满,则链表尾结点删除,将新的插入到头部
        - 此时,不管缓存有没有满,我们都需要遍历一遍链表,所以这种基于链表的实现思路,时间复杂度为O(n).**而散列表可以将时间复杂度降到O(1).**
   - 数组和链表性能比拼
     + 数组开辟的是一块连续的内存空间.
        1. 缺点: 大小固定,一经声明占用整块连续内存空间,若声明的数组过大,系统可能没有足够的连续内存分配给他导致内存不足.或者声明过小需要扩容
     + 链表不是连续存储
        1. 缺点: 对CPU缓存不友好,没有办法有效预读.
        2. 优点: 大小没有限制,天然的支持动态扩容
                
        
   