## 常见数据结构
### 数据结构目录
   - 数组
   - 链表
   - 散列表
   - 树
        + 二叉树
        + 红黑树
        + B-Tree
        + B+Tree
        + 多路查找树   
   - 图
   - 队列
   - 堆
   - 栈
   

### 常见算法目录
   - 快速排序
   - 冒泡排序
   - 插入排序
   - 递归
   - 冒泡排序
   - 斐波那契算法
   
##### 数据结构入门
###### 1. 时间复杂度 [表示算法的执行时间和数据规模之间的增长关系]
![ 这是一个图片 ](image/TimeComplexity.png)
   - 加法法则
     + 总的时间复杂度为量级最大的那段代码的时间复杂度.
       时间复杂度为O(n)
     + 若有两个不定量级的数据规模,如(m,n). 时间复杂度为O(m+n)
   - 乘法法则
     + 通常用于嵌套循环中,如一个循环中调用了另一个循环函数.
     那么该代码的时间复杂度为O(n²)
     + 若为多个不定量级,则复杂度为O(n*m)等
   - 常见的时间复杂度
     - 多项式量级
       + O(1): 常量阶[代码的执行时间不随着不定量级的增长而增长]
       + O(logn): 对数阶[等比数列]
       + O(n): 线性阶
       + O(nlogn): 线性对数阶[循环内嵌套对数阶]
       + O(n²): 平方阶
       + O(n³): 立方阶
       + O(nk): k次方阶
     - 非多项式量级(随着数据规模越大,执行时间急剧增加)
       + O(2n): 指数阶
       + O(!n): 阶乘阶
      
###### 2. 空间复杂度 [表示存储空间和数据规模之间的增长关系]
   - 常见的空间复杂度
     + O(1): 常量阶
     + O(n): 线性阶[new一个不定量级长度的对象/数组等]
     + O(n²)
     + O(logn)/O(nlogn): 不常用

###### 3. 时间复杂度细化
   - 最好情况时间复杂度
     + 最理想情况下出现的时间复杂度
   - 最坏情况时间复杂度
     + 最坏情况下出现的时间复杂度
   - 平均情况时间复杂度
     + 一般为加权平均值(需要考虑到各种情况,进行运算) 一般为O(n)
   - 均摊时间复杂度
     + 大多数为一种情况,偶然出现第二种情况,那么均摊时间复杂度为情况一
       
##### 数据结构基础篇
###### 1. 数组
   - 概念
     + 数组: 是一种线性表数据结构,用一组连续的内存空间来存储相同类型的数据
     + 线性表: 是数据排成像线一样的结构,每个线性表只有前或后两个方向. 如: 数组,链表,栈,队列都属于线性表
     + 非线性表: 数据间并不是简单的前后关系. 如: 堆,图,树等
   - 数组特点
     + 连续的内存空间和相同类型的数据
        1. 优点: 随机访问
        2. 缺点: 为保证连续性,需要做大量的数据搬移工作
     + 数据根据下标随机访问的实现
        1. 计算机通过该数组的内存地址访问,寻址公式: a[i]_address = base_address + i * data_type_size(表示数组中每个元素的大小,单位字节).
        其实下表最确切的定义是偏移.如果用a标识数组的首地址,a[0]就是偏移为0的位置.a[k]就表示偏移k个type_size的位置,所以用上述公式就可以了.
        但如果下标从1开始,后续i的计算都需要-1. 即: base_address + (k-1) * type_size.
        所以如果从1开始,CPU就多了一次减法指令,这也是下标为0的原因.当然,也可能是历史原因,因为从C语言开始,设计者就用0做数组下标.
        2. 根据数组下标随机访问的时候,时间复杂度为O(1). 而整体查找的时间复杂度,几遍是排好序的数组,用二分查找,时间复杂度也是O(logn).链表的增删改则为O(1)
     + 低效的插入和删除
        1. 数组具有连续性,会导致插入删除这两个操作比较低效. 因为他是把插入位置以后的数据进行移动,所以平均时间复杂度是(1+2+3+...+n)/n = O(n)
        如果数据是有序的,就必须将后续数据进行移动,若是无序的,则可以更换位置,如: 将插入位置的原数据放到数组最后,把新元素放入插入位置.
        2. 删除时除了上述移动后续数据的方法,某些特殊场景下,我们可以先把删除的数据进行标记,等到数组没有更多空间的时候,在触发执行一次真正的删除.这样可以大大减少删除操作导致的数据搬移. 这一点和JVM的标记清除垃圾回收算法的核心思想一样
   - 容器和数组的使用场景
     + ArrayList容器
        1. 讲很多数组操作的细节进行封装,且支持动态扩容.但因为扩容操作设计内存申请和数据搬移,比较耗时,所以如果能事先确定好需要存储的数据大小,最好在创建的时候指定大小
     + 数组
        1. 因为容器不支持基本数据类型,而封装类是有一定性能消耗的,所以如果特别关注性能追求极致,或者需要使用基本数据类型,可以使用数组. 若是数据大小事先已知,并且对数据操作简单,用不到大多数封装方法,也可以直接使用数组
        
###### 2. 链表
   - 概念
   